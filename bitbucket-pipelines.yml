# Example Bitbucket Pipeline for client applications using pulumi-gcp-ops
#
# Copy this file to your application repository and customize as needed.
#
# Required Repository Variables:
#   GCP_PROJECT          - GCP project ID
#   GCP_PROJECT_NUMBER   - GCP project number (for WIF)
#   GCP_REGION           - GCP region (e.g., us-central1)
#   STATE_BUCKET         - GCS bucket name for Pulumi state
#   SERVICE_ACCOUNT_EMAIL - Deploy service account email
#   APP_NAME             - Application name prefix
#   PULUMI_ORG           - Pulumi organization/username
#
# Required Repository Variables (Secured):
#   PULUMI_CONFIG_PASSPHRASE - State encryption passphrase
#
# Optional Repository Variables:
#   CPU_LIMIT            - CPU limit (default: 1)
#   MEMORY_LIMIT         - Memory limit (default: 512Mi)
#   MIN_INSTANCES        - Minimum instances (default: 0)
#   MAX_INSTANCES        - Maximum instances (default: 100)

image: node:22-alpine

definitions:
  services:
    docker:
      memory: 2048

  steps:
    - step: &deploy
        name: Deploy to Cloud Run
        oidc: true
        services:
          - docker
        caches:
          - node
          - docker
        script:
          # Install dependencies
          - apk add --no-cache git curl jq bash docker-cli

          # Clone infrastructure repo
          - git clone https://bitbucket.org/${BITBUCKET_WORKSPACE}/pulumi-gcp-ops.git infra

          # Normalize branch name for Cloud Run
          - export BRANCH_TAG=$(./infra/scripts/normalize-branch.sh "$BITBUCKET_BRANCH")
          - echo "Deploying branch '${BITBUCKET_BRANCH}' as '${BRANCH_TAG}'"

          # Get GCP access token via Workload Identity Federation
          - |
            export GCP_PROJECT_NUMBER="${GCP_PROJECT_NUMBER}"
            export SERVICE_ACCOUNT_EMAIL="${SERVICE_ACCOUNT_EMAIL}"
            export ACCESS_TOKEN=$(./infra/scripts/get-wif-token.sh)
            if [ -z "$ACCESS_TOKEN" ]; then
              echo "Failed to get GCP access token"
              exit 1
            fi

          # Configure gcloud-like auth for Docker and Pulumi
          - export CLOUDSDK_AUTH_ACCESS_TOKEN="${ACCESS_TOKEN}"
          - export GOOGLE_OAUTH_ACCESS_TOKEN="${ACCESS_TOKEN}"

          # Get registry URL from infrastructure stack
          - cd infra/infrastructure
          - npm ci --silent
          - npx pulumi login "gs://${STATE_BUCKET}"
          - export REGISTRY_URL=$(npx pulumi stack output registryUrl -s ${PULUMI_ORG}/infrastructure/prod --show-secrets 2>/dev/null)
          - echo "Registry URL:${REGISTRY_URL}"
          - cd ../..

          # Build and push Docker image
          - echo "${ACCESS_TOKEN}" | docker login -u oauth2accesstoken --password-stdin "https://${GCP_REGION}-docker.pkg.dev"
          - docker build -t "${REGISTRY_URL}/${APP_NAME}:${BRANCH_TAG}" .
          - docker push "${REGISTRY_URL}/${APP_NAME}:${BRANCH_TAG}"

          # Deploy via Pulumi
          - cd infra/app
          - npm ci --silent
          - npx pulumi stack select "${PULUMI_ORG}/app/${APP_NAME}-${BRANCH_TAG}" --create 2>/dev/null || true
          - npx pulumi config set gcp:project "${GCP_PROJECT}"
          - npx pulumi config set appName "${APP_NAME}"
          - npx pulumi config set imageTag "${BRANCH_TAG}"
          - npx pulumi config set infraStackRef "${PULUMI_ORG}/infrastructure/prod"
          - npx pulumi config set region "${GCP_REGION}"

          # Optional configuration
          - |
            if [ -n "${CPU_LIMIT}" ]; then
              npx pulumi config set cpuLimit "${CPU_LIMIT}"
            fi
            if [ -n "${MEMORY_LIMIT}" ]; then
              npx pulumi config set memoryLimit "${MEMORY_LIMIT}"
            fi
            if [ -n "${MIN_INSTANCES}" ]; then
              npx pulumi config set minInstances "${MIN_INSTANCES}"
            fi
            if [ -n "${MAX_INSTANCES}" ]; then
              npx pulumi config set maxInstances "${MAX_INSTANCES}"
            fi

          - npx pulumi up --yes

          # Get deployment URL and run health check
          - export URL=$(npx pulumi stack output url --show-secrets 2>/dev/null)
          - echo "Deployed to ${URL}"
          - |
            echo "Running health check..."
            for i in $(seq 1 6); do
              if curl -sf "${URL}/health" > /dev/null 2>&1; then
                echo "Health check passed!"
                exit 0
              fi
              echo "Attempt $i/6 failed, retrying in 10s..."
              sleep 10
            done
            echo "Health check failed after 60 seconds"
            exit 1

    - step: &cleanup
        name: Cleanup Branch Resources
        oidc: true
        script:
          # Install dependencies
          - apk add --no-cache git curl jq bash

          # Clone infrastructure repo
          - git clone https://bitbucket.org/${BITBUCKET_WORKSPACE}/pulumi-gcp-ops.git infra

          # Normalize the deleted branch name
          - export BRANCH_TAG=$(./infra/scripts/normalize-branch.sh "$DELETED_BRANCH")
          - export STACK_NAME="${APP_NAME}-${BRANCH_TAG}"
          - echo "Cleaning up stack '${STACK_NAME}' for deleted branch '${DELETED_BRANCH}'"

          # Get GCP access token via Workload Identity Federation
          - |
            export GCP_PROJECT_NUMBER="${GCP_PROJECT_NUMBER}"
            export SERVICE_ACCOUNT_EMAIL="${SERVICE_ACCOUNT_EMAIL}"
            export ACCESS_TOKEN=$(./infra/scripts/get-wif-token.sh)
            export CLOUDSDK_AUTH_ACCESS_TOKEN="${ACCESS_TOKEN}"
            export GOOGLE_OAUTH_ACCESS_TOKEN="${ACCESS_TOKEN}"

          # Check if stack exists and destroy
          - cd infra/app
          - npm ci --silent
          - npx pulumi login "gs://${STATE_BUCKET}"
          - |
            if npx pulumi stack select "${PULUMI_ORG}/app/${STACK_NAME}" 2>/dev/null; then
              echo "Stack exists, destroying..."
              npx pulumi destroy --yes
              npx pulumi stack rm --yes
              echo "Stack '${STACK_NAME}' destroyed successfully"
            else
              echo "No stack found for '${STACK_NAME}', nothing to clean up"
            fi

          # Optional: Delete Docker image from Artifact Registry
          - |
            echo "Cleaning up Docker image..."
            curl -s -X DELETE \
              -H "Authorization: Bearer ${ACCESS_TOKEN}" \
              "https://${GCP_REGION}-docker.pkg.dev/v2/${GCP_PROJECT}/${REGISTRY_NAME}/${APP_NAME}/manifests/${BRANCH_TAG}" \
              || echo "Image already deleted or not found"

pipelines:
  branches:
    '**':
      - step: *deploy

  custom:
    cleanup-branch:
      - variables:
          - name: DELETED_BRANCH
            description: "Name of the deleted branch to clean up"
        step: *cleanup

# Webhook configuration for automatic cleanup:
# 1. Go to Repository Settings > Webhooks
# 2. Add webhook URL: https://api.bitbucket.org/2.0/repositories/{workspace}/{repo}/pipelines/
# 3. Select trigger: Branch deleted
# 4. The webhook should trigger the cleanup-branch custom pipeline
