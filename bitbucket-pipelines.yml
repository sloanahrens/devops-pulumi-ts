# Example Bitbucket Pipeline for client applications using devops-pulumi-ts
#
# Copy this file to your application repository and customize APP_NAME below.
# This template uses parallel build+deploy for faster CI/CD.
#
# Required Repository Variables:
#   GCP_PROJECT          - GCP project ID (infra project where Cloud Run deploys)
#   GCP_PROJECT_NUMBER   - GCP project number (for WIF)
#   GCP_REGION           - GCP region (e.g., us-central1)
#   STATE_BUCKET         - GCS bucket name for Pulumi state
#   SERVICE_ACCOUNT_EMAIL - Deploy service account email
#
# Required Repository Variables (Secured):
#   PULUMI_CONFIG_PASSPHRASE - State encryption passphrase
#
# Optional Repository Variables:
#   CPU_LIMIT            - CPU limit (default: 1)
#   MEMORY_LIMIT         - Memory limit (default: 512Mi)
#   MIN_INSTANCES        - Minimum instances (default: 0)
#   MAX_INSTANCES        - Maximum instances (default: 100)
#   RUNTIME_SERVICE_ACCOUNT_EMAIL - Runtime SA for apps with backend resources
#
# CLI Deploy Options:
#   --port <port>                    - Container port (default: 8080)
#   --memory <size>                  - Memory limit, e.g., "1Gi" (default: 512Mi)
#   --custom-domain <domain>         - Map custom domain (production only)
#   --build-args-from-env "<vars>"   - Pass env vars as Docker build args
#
# NOTE: Stack References
# ----------------------
# This pipeline uses "organization" as a literal string in stack references
# (e.g., "organization/infrastructure/prod"). This is the convention for
# self-managed Pulumi state backends (GCS, S3, Azure Blob). You do NOT need
# a Pulumi Cloud account - the state is stored in your GCS bucket.
#
# =============================================================================
# Apps with Backend Resources (Firestore, Firebase, Secret Manager, etc.)
# =============================================================================
#
# For stateless apps: No additional setup needed.
#
# For apps with backend resources in a separate GCP project:
#
#   1. Create runtime SA in your app's GCP project with required permissions:
#      gcloud iam service-accounts create app-runtime \
#        --project=APP-PROJECT \
#        --display-name="App Runtime Account"
#
#   2. Grant runtime SA access to your backend resources:
#      gcloud projects add-iam-policy-binding APP-PROJECT \
#        --member="serviceAccount:app-runtime@APP-PROJECT.iam.gserviceaccount.com" \
#        --role="roles/datastore.user"  # Firestore
#
#   3. Grant deploy SA permission to assign the runtime SA to Cloud Run:
#      gcloud iam service-accounts add-iam-policy-binding \
#        app-runtime@APP-PROJECT.iam.gserviceaccount.com \
#        --member="serviceAccount:pulumi-deploy@INFRA-PROJECT.iam.gserviceaccount.com" \
#        --role="roles/iam.serviceAccountUser"
#
#   4. Set RUNTIME_SERVICE_ACCOUNT_EMAIL in repository variables
#
# The Cloud Run service deploys to the infra project but runs as the runtime SA,
# which has cross-project access to your app's backend resources.
# =============================================================================

image: node:22-alpine

definitions:
  services:
    docker:
      memory: 2048

  steps:
    - step: &build-test
        name: Build and Test
        caches:
          - node
        script:
          - npm ci
          - npm run build
          - npm run lint
          - npx tsc --noEmit

    - step: &deploy
        name: Deploy to Cloud Run
        oidc: true
        services:
          - docker
        caches:
          - node
          - docker
        script:
          - apk add --no-cache git curl bash
          - curl -fsSL https://get.pulumi.com | sh
          - export PATH=$PATH:$HOME/.pulumi/bin
          - git clone https://bitbucket.org/YOUR_WORKSPACE/devops-pulumi-ts.git infra
          - cd infra/cli && npm ci && npm run build
          # Customize: replace YOUR_APP_NAME, add --port/--memory/--build-args-from-env as needed
          - npx devops-deploy deploy --cloud gcp --app YOUR_APP_NAME --branch "$BITBUCKET_BRANCH" --context "$BITBUCKET_CLONE_DIR"
          - echo "Service URL - $(cat /tmp/service-url.txt)"

    # Production deploy with custom domain (uncomment and customize for main branch)
    # - step: &deploy-production
    #     name: Deploy to Cloud Run (Production)
    #     oidc: true
    #     services:
    #       - docker
    #     caches:
    #       - node
    #       - docker
    #     script:
    #       - apk add --no-cache git curl bash
    #       - curl -fsSL https://get.pulumi.com | sh
    #       - export PATH=$PATH:$HOME/.pulumi/bin
    #       - git clone https://bitbucket.org/YOUR_WORKSPACE/devops-pulumi-ts.git infra
    #       - cd infra/cli && npm ci && npm run build
    #       - npx devops-deploy deploy --cloud gcp --app YOUR_APP_NAME --branch "$BITBUCKET_BRANCH" --context "$BITBUCKET_CLONE_DIR" --custom-domain your-domain.com
    #       - echo "Service URL - $(cat /tmp/service-url.txt)"

pipelines:
  default:
    - parallel:
        - step: *build-test
        - step: *deploy

  # Uncomment for production branch with custom domain:
  # branches:
  #   main:
  #     - parallel:
  #         - step: *build-test
  #         - step: *deploy-production

  custom:
    branch-cleanup:
      - variables:
          - name: DELETED_BRANCH
            description: "Name of the deleted branch to clean up"
        step:
          name: Cleanup Branch Resources
          oidc: true
          script:
            - apk add --no-cache git curl bash
            - curl -fsSL https://get.pulumi.com | sh
            - export PATH=$PATH:$HOME/.pulumi/bin
            - git clone https://bitbucket.org/YOUR_WORKSPACE/devops-pulumi-ts.git infra
            - cd infra/cli && npm ci && npm run build
            # Must match app name from deploy steps
            - npx devops-deploy cleanup --cloud gcp --app YOUR_APP_NAME --branch "$DELETED_BRANCH"
